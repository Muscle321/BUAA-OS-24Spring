# 思考题
---
## Thinking 2.1
---
虚拟地址；虚拟地址

## Thinking 2.2
---

	如果在一个工程中想要同时使用整型的链表和浮点型的链表，就要定义两个结构体，并且同样的操作节点的代码要写两遍；若在C语言中借助 `void*` 指针，利用强制类型转换的方法实现多态，可能会出现无法确定数据存储位置而导致出错的情况，也可能会出现隐式类型转换等错误；所以我们用宏实现链表，可以在C语言中实现多态和重载，这样的话就可以减少劳动力，并且并能够提高效率，增强代码可读性；

- SLIST是单向无尾链表，它的删除操作直接使得该节点的上一个节点指向该节点的下一个节点即可，如果该节点是头节点，那就将头节点移除即可；插入操作只能插入目标节点的下一个节点，直接更改指针即可；
- STAILQ是单向有尾链表，删除操作和前者区别在如果是尾节点，那么需要使得上一个节点的指针指向NULL；插入操作在于如果插入尾部，那就直接改变尾节点即可；
- CIRCLEQ是循环链表，他就是尾节点指向头节点，删除和插入操作和单向链表基本相同，只需要判断是否为头尾节点，并且更新头尾节点即可；

| 链表类型 | 插入操作时间复杂度 | 删除操作时间复杂度 |
| ---- | --------- | --------- |
| 单向链表 | O(n)      | O(n)      |
| 循环链表 | O(n)      | O(n)      |
| 双向链表 | O(1)      | O(1)      |

## Thinking 2.3
---
C
## Thinking 2.4
---

	在虚拟内存环境中，每个进程通常被赋予一个独立的虚拟地址空间。然而，实际的物理内存是有限的，因此多个进程的虚拟地址空间需要通过某种机制映射到物理内存上。ASID在这种机制中起到了关键作用。它允许操作系统和硬件识别不同的地址空间，确保每个进程只能访问其自己的虚拟地址空间，从而实现了进程间的内存隔离。
	在多进程操作系统中，同时运行的进程数量可能非常多。每个进程都有自己的虚拟地址空间，这些地址空间之间需要进行区分和管理。ASID为每个地址空间提供了一个唯一的标识符，使得操作系统可以方便地跟踪和管理每个进程的地址空间。

	ASID段有8位，所以4Kc中能容纳地址空间的最大数量为256
## Thinking 2.5
---

- tlb_invalidate 调用了 tlb_out； 
- 实现删除特定虚拟地址的映射，每当页表被修改，就需要调用该函数以保证下次访问相应虚拟地址时一定触发 TLB 重填，进而保证访存的正确性。

``` mips
LEAF(tlb_out)
.set noreorder
	mfc0    t0, CP0_ENTRYHI //CP0_ENTRYHI中原有的值写入t0寄存器
	mtc0    a0, CP0_ENTRYHI //然后将a0寄存器中的值写入CP0_ENTRYHI中
	nop
	tlbp  //查找 TLB 中与之对应的表项，并将表项的索引存入 Index 寄存器
	nop
	mfc0    t1, CP0_INDEX //CP0_ENTRYHI中现在的值写入t1寄存器
.set reorder
	bltz    t1, NO_SUCH_ENTRY //判断t1寄存器的值是否小于0，
	//如果k0寄存器的值小于0，就跳转到NOFOUND所在位置，
	//如果k0寄存器值不小于0，把HI和LO寄存器清空，
	//并以Index寄存器中的值为索引，将此时ENTYRYHI与ENTRYLO的值写到索引所对应的TLB中
.set noreorder
	mtc0    zero, CP0_ENTRYHI
	mtc0    zero, CP0_ENTRYLO0
	mtc0    zero, CP0_ENTRYLO1
	nop
	tlbwi
.set reorder
```

## Thinking 2.6
---

	X86体系结构是一种常见的计算机体系结构，其内存管理机制主要包括分段和分页两种方式。
	1. 分段：X86使用分段机制来管理内存。在分段机制中，内存被划分为多个段，每个段具有不同的属性和大小。段选择子用于指定当前正在使用的段，通过段选择子和偏移量可以计算出实际的物理地址。分段机制可以提供更灵活的内存管理，但也增加了复杂性。
	2. 分页：X86还使用分页机制来管理内存。在分页机制中，内存被划分为固定大小的页，通常为4KB。每个页都有一个对应的页表项，用于将虚拟地址映射到物理地址。通过页表，操作系统可以实现虚拟内存和物理内存之间的映射关系。分页机制可以提供更大的地址空间和更好的内存保护。
	不同点：
	- MIPS使用分段和分页的组合方式来管理内存。与X86不同的是，MIPS的分段机制主要用于实现内存保护和共享，而不是提供灵活的内存管理。
	- MIPS采用固定大小的页（通常为4KB）进行分页，与X86相同。但是，MIPS的页表结构和X86有所不同，MIPS使用两级页表结构，而X86使用多级页表结构。
	- MIPS的分页机制相对简单，没有提供像X86那样的特性，如页面大小的动态调整、写时复制等。

## Thinking A.1
---
- 第0x7fc00000>>12个页表项相对于页表基地址的偏移为`(0x7fc00000>>12)*8=0x3fe000`，页目录基地址为0x7fffe000;
- `(0x7fc00000 >> 22) * 8 + 0x7fc00000 = 0x7fffeff8`;

# 难点分析
---
我觉得这次实验主要难在两部分，一是物理内存空间的分配，二是虚拟内存的管理，最后TLB的清除与重填我也没有怎么搞清楚，但是实验要求不是很多，所以我们再次重点分析前两部分。

首先我们要知道在三个不同段对应内存管理方式不一样，kseg0和kseg1访问相对简单，kuseg访问相对复杂；

## 物理内存空间的分配
---
主要包括三个步骤：
1. 初始化，首先通过`mips_detect_memory` 函数对内存进行初始化操作；
2. 建立内存管理机制，调用 `alloc` 函数分配空间并且使他们对齐；
3. 进行物理内存空间管理，如下操作：


- 首先，我们采用双向链表用于存储空闲的物理内存页，我们需要注意的是他的一个指针指向下一个结构体，另一个指针指向上一个结构体的指向下一个结构体的成员，主要是便于删除和插入操作，这里有点绕，但是结合图很容易理解；
![[Pasted image 20240410215856.png]]
- 接着，我们定义了许多宏函数允许对该结构体进行一系列的操作；插入删除初始化等等操作；比较简单；
- 最后，我们定义一些关于物理内存管理的函数；
	- `page_init()`: 初始化宏链表`page_free_list`；
	- `page_alloc(struct Page **pp)`: 分配物理页面空间 ，将pp指向的空间赋值为这个页控制块的地址；
	- `page_decref(struct Page *pp)`：令pp对应页控制块的引用次数减少1，如果为0则释放；
	- `page_free(struct Page *pp)`：释放对应的物理空间，并将它重新加入到空闲链表中；
这个难点在于理解这些宏函数和函数之间的关系，理解物理内存分配的方式；

## 虚拟内存管理
---
虚拟内存通过两级页表来进行管理，所以显得有些复杂，一定要在理解了物理内存管理相关函数的基础上才能理解虚拟内存管理的机制；
![[Pasted image 20240410220847.png]]
上图为虚拟内存映射到物理内存的方式，也是我们要完成的结构；实际上第一级页表和第二级页表的结构完全一样，连页号位都一样，为了区分它们只是名称不一样而已；

具体如何查找映射关系不再多说，理论课已经讲的很明白了；

我们重点介绍与页表相关的函数：
- `int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)`：该函数将一级页表基地址pgdir对应的两级页表结构中va虚拟地址所在的二级页表项的指针存储在ppte指向的空间上，如果create不为0且对应的二级页表不存在，就进行分配一页物理内存用于存放二级页表；下图为操作流程；也就是说通过一级页表和虚拟地址，查找va的二级页表
![[Pasted image 20240410221544.png]]
- `int page_insert(Pde *pgdir, u_int asid, struct Page *pp, u_long va, u_int perm)`：是将一级页表基地址 pgdir 对应的两级页表结构中虚拟地址 va 映射到页控制块 pp 对应的物理页面，并将页表项权限为设置为 perm；也就是说填写va对应的一级页表
- `struct Page * page_lookup(Pde *pgdir, u_long va, Pte **ppte)`：返回一级页表基地址pgdir对应的两级页表结构中虚拟地址 va 映射的物理页面的页控制块，同时将 ppte 指向的空间设为对应的二级页表项地址；也就是说将ppte指向va所对应的二级页表，并且返回va对应的物理页；
- `void page_remove(Pde *pgdir, u_int asid, u_long va)`：作用是删除一级页表基地址 pgdir 对应的两级页表结构中虚拟地址 va 对物理地址的映射。如果存在这样的映射，那么对应物理页面的引用次数会减少一次；也就是说，取消va对应物理空间的引用；
对于虚存管理，我觉得只要理解了这几个函数的作用就够了，有些难理解，但是可以结合着代码和理论知识以及图片来理解；
## 关于TLB
---
- TLB首先对应许多cp0寄存器，我这里不一一叙述了；
- 接着，对于TLB组成，它包括一组key和两组data；
	- 我们发现他有三个寄存器，分别为EntryHi、EntryLo0、EntryLo1，第一个寄存器可以将虚拟地址映射到两个相邻页面中（这里我不理解为什么不能直接映射到一个页面中呢？），相当于key；再通过后两个寄存器储存的data来进行返回；
	- 实际上TLB的映射为![[Pasted image 20240410222829.png]]
- 最后，我们了解一些TLB的指令
	- tlbr：以 Index 寄存器中的值为索引，读出 TLB 中对应的表项到 EntryHi 与 EntryLo0、EntryLo1；
	- tlbwi：以 Index 寄存器中的值为索引，将此时 EntryHi 与 EntryLo0、EntryLo1 的值写到索引指定的 TLB 表项中；
	- tlbwr：将 EntryHi 与 EntryLo0、EntryLo1 的数据随机写到一个 TLB 表项中（此处使用 Random 寄存器来“随机”指定表项，Random 寄存器本质上是一个不停运行的循环计数器）；
	- tlbp：根据 EntryHi 中的 Key（包含 VPN 与 ASID），查找 TLB 中与之对应的表项，并将表项的索引存入 Index 寄存器（若未找到匹配项，则 Index 最高位被置 1）；

我们在操作系统中维护 TLB 的流程如下： 
1. 更新页表中虚拟地址对应的页表项的同时，将 TLB 中对应的旧表项无效化 ；
	- 通过tlb_invalidate函数删除特定虚拟地址在TLB中的旧表项，即使其无效化；
2. 在下一次访问该虚拟地址时，硬件会触发 TLB 重填异常，此时操作系统对 TLB 进行重填；
	- 通过do_tlb_refill函数完成对tlb的重填；
# 实验体会
---
这次实验的总体难度还行，刚开始有点迷，但是逐步了解了物理内存管理和虚拟内存管理的机制后发现实验容易理解多了，结合着代码一行一行读，读懂每一个函数，再结合理论知识，就慢慢了解了操作系统在内存管理的应用；

我觉得操作系统这门课理论知识和实验一定是紧密相连的，这次实验刚开始我对理论不太了解的情况下就想上手去做实验，给我造成了很大的困难，但是我在详细了解了理论知识之后，再次去学习实验的时候，虽然花费了很长的时间，但是我真的了解到了这方面的知识，对实验有了更深的理解，并且我对理论知识的印象也更加深刻了。所以，我觉得理论课一定不能拉下，一定要和理论课结合着学习操作系统这门课。

这次上机exam比较简单，extra也不是很难，但是不知道为什么我就是不对，也不知道bug在哪里，只好课下去讨论一下bug所在了。







