# 思考题
---
## Thinking 3.1
---
`e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_V` 上面代码意为将进程页目录中虚拟地址 UVPT 对应的页目录项置为存放该进程的页目录的物理页面的物理页号，并将权限置为只读；
这一行代码的意义就是，让用户能够读取 `UVPT` 对应地址的物理内存，这部分物理内存存放该页目录的物理基地址，也就是用户可以读取进程的页目录项，用户可以通过访问这部分空间得到二级页表以及页目录中的数据。
## Thinking 3.2
---
`data` 参数来源于 `load_icode_mapper` 中的 `data` ，该参数的作用是传递 `env` 结构的地址，然后此函数用作回调；如果没有这个参数，就无法找到 `env` 结构体的地址，少了这个参数回调函数就无法实现，因为无法获取该进程的信息；
## Thinking 3.3
---
头不对齐尾对齐，头尾都对齐，头对齐尾不对齐，头尾都不对齐；

最坏的情况即为指导书中给出的首尾均不对齐的情况；

若内存的首地址没有页对齐，则需要分配一页来存它；若加载text和data段后末尾未页对齐，需要再分配一页存储尾部；如果前一段未页对齐，并且bss段的首地址也未页对齐，需要再分配一页存储，并将相应的地方清空；如果bss段末尾未对齐，需要单独分配一页存储，并将其清空。
## Thinking 3.4
---
虚拟地址，因为它的地址是从入口地址复制的，入口地址即为虚拟地址；
## Thinking 3.5
---
都在 `genex.S` 中；
## Thinking 3.6
---
首先 `env_asm.S` 中，在进程运行 `env_run` 的时候，我们调用 `env_pop_tf` ，这个函数重置了时钟参数，然后时钟计数器不断地运行，最后达到设定的阈值后，进入 `exc_gen_entry` 代码段运行；
接着，在 `exc_gen_entry` 代码段中，我们最后处理 `handle_int` 时钟中断;
然后，`handle_int` 函数根据 Cause 寄存器的值判断是否是 Timer 对应的 7 号中断位引发的时钟 中断，如果是，则执行中断服务函数 `timer_irq`，跳转到 `schedule` 中执行;
最后，执行完毕后返回；

时钟中断在进程运行时开启，当 `count` 寄存器和 `compare` 寄存器相等时进入；
在 `schedule` 函数执行完毕后下个进程开始运行前关闭；
## Thinking 3.7
---
根据 `schedule` 函数，OS设置了两个链表队列，最开始时在队列1中。定时器负责产生中断，若时间片未用完，则时间片-1；当前进程的时间片用完之后，会将其从当前的队列取出，装入另一个队列的队尾。之后取出当前队列的头部进程，若为RUNNABLE状态，则执行，否则继续查找至找到为止。当前队列若为空，则切换另一个队列查找，如此进行调度。
# 难点分析
---
在Lab3中，我们重点关注3个问题：
- OS启动时为进程做了哪些初始化工作；
- OS创建进程时做了什么事情；
- 进程是如何运行并切换的；
但是，我认为最难的几个地方分别为与进程相关的操作函数，进程调度这三个部分，我们一个一个分析；
## 进程
---
1. 我们首先要知道每个进程都存在一个唯一的PCB（进程控制块），每个进程与PCB是一一对应的。而对于PCB，我们是由一个env结构体实现的，其中包括许多变量，变量解释在指导书中都有，在此不多解释；
2. 每个进程都有一个特殊的标识ASID，这在lab2中已经解释，在此不多做解释；


进程中包括以下函数：
1. 进程初始化函数 `env_init` ：这个函数实现了初始化进程块的空闲队列喝调度队列，这个函数在OS启动的时候使用；
	- 有个子函数 `map_segment` ：这个函数的作用是在一级页表基地址 `pgdir` 对应的二级页表结构中做段地址映射，将虚拟地址段映射到物理地址段，`size` 必须是页面大小的整数倍，并且将页表项权限设置为 `perm`；
2. 进程分配函数 `env_alloc` ：这个函数实现了进程的创建，利用空闲链表 `env_free_list` 创建进程，并且将new指向新创建的进程；
	- `mkenvid` 函数：这个函数是创建一个进程id，并且使得每一个进程的id都不一样；
	- `asid_alloc` 函数：这个函数是申请一个asid编号，ASID决定了该系统最多有256个进程项，如果超出则就发出异常；
	- `env_setup_vm` 函数：这个函数主要是创建进程虚拟地址空间；
3. 加载二进制镜像函数 `load_icode` ：该函数负责加载可执行文件到进程的内存中；
	- `elf_from` 函数：这个函数负责解析ELF文件头的部分；
	- `elf_load_seg` 函数：这个函数负责将ELF文件的一个 `segment` 加载到内存，而这个函数中接受一个回调函数 `map_page` ，这个函数由 `load_icode_mapper` 实现，即分配页面；（多种情况已经在练习题中说明）
4. 进程创建函数 `env_create` ：用 `env_alloc` 分配一个进程，接着设置其优先级和运行状态，并且用 `load_icode` 将程序载入到该进程的地址空间；
5. 进程运行函数 `env_run` ：保存当前进程的上下文，然后恢复启动的进程的上下文，运行该进程；其中调用 `env_pop_tf` 函数进行恢复现场，异常返回；
## 进程调度
---
大部分理论基础知识在计组已经学习过了，我们主要考虑如何进行异常的处理，也就是计组中所说的软件操作的；

异常相关的代码在如下文件：
1. `entry.S` ：这个文件包括一段异常分发代码`exc_gen_entry`，用于响应对应的异常，这些异常存在 `exception_handlers` 数组中，称为异常向量组，不同的异常对应不同的异常码，从而进入不同的异常处理位置；
2. `genex.S` ：这个文件包括许多异常处理函数，`handle_int` 等异常处理；
3. `env_asm.S` ：这个文件包括的代码就是初始化时钟中断；

最后就是进程调度函数 `schedule` ：这个函数通过时钟中断更改 `count` 值实现了进程的调度，这个函数非常的关键，难度不大，但是出bug后debug非常的难，关键代码![[Pasted image 20240422201420.png]]
# 实验体会
---
本次实验难度还行，可能是我知道了学习OS需要和理论知识结合，当我把我学过的理论知识和实验结合后，就觉得这次实验简单了许多；

这次实验我用的时间比lab2少多了，可能使lab2让我读懂了大部分宏函数和代码，理解了OS代码的架构，我就对OS的实现理解更深刻了，在学习lab3的时候就更加了解文件函数之间的依赖关系，让我学习更加方便了；

接着就是，实验的PPT对我的帮助也挺大的，那些图解让许多难以理解的概念变得更加透彻；

然后就是，我还是觉得学习OS一定一定要把理论知识学会，理论知识不知道的时候学习实验真的好难，也许是最近期中考试，让我复习了一下理论知识，使得这次实验不是那么困难；

最后就是，一定要学会debug，实际上我们用的算法并不难实现，但是除了bug之后debug是真的困难，尤其是 `schedule` 调度函数，算法竟然不是最难的，最难的还是debug。