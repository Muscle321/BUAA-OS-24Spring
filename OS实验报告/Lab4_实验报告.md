# 思考题
---
## Thinking 4.1
---
- 通过 `SAVE_ALL` 宏来保存现场，其中k0寄存器暂存了sp栈指针的值，k1寄存器更新sp栈指针的值，除k0、k1之外所有的通用寄存器都在修改之前被保存了，k0和k1是可以暂时被随意改变的寄存器，因此修改也没关系。
- 可以，a0-a3寄存器没有被修改过。
- 调用的时候代码将参数加载到了sys开头函数认为的位置。
- 对Trapframe结构体中的cp0_epc的值增加了4，将sys开头函数的返回值存入v0寄存器。系统调用结束后，从syscall的下一条开始执行。

## Thinking 4.2
---
因为可能存在某个 `envid` 对应的进程e完成运行，资源被回收，这时其对应的进程控制块会插入回 `env_free_list` 中。当我们需要再次创建内存时，就可能重新取得该进程控制块，并为其赋予不同的 envid。这时，已销毁进程的 envid 和新创建进程的 envid 都能通过 `ENVX` 宏取得相同的值，对应了同一个进程控制块。可是已销毁进程的 envid 却不应当再次出现，`e->env_id != envid` 就处理了 `envid` 属于已销毁进程的情况。，即为了判断该 `envid` 的值是合理且对应进程存在；如果没有这一步，调用该函数如果传入一个非法的 `envid` 就会导致崩溃，使得 `penv` 指针指向非法的地址；

## Thinking 4.3
---
```cpp
u_int mkenvid(struct Env *e) {
    static u_int i = 0;
    return ((++i) << (1 + LOG2NENV)) | (e - envs);
}
```
该函数的实现满足返回值第11位往上永远不为0，所以 `mkenvid()` 一定不会创建 `envid` 为0的进程，而通过 `envid2env()` 函数的实现，可以实现通过传入参数 `envid` 为0来返回指向当前进程的指针，非常方便；
## Thinking 4.4
---
C，子进程在fork()中通过函数`syscall_env_alloc()`被创建，随后子进程会从`syscall_env_alloc()`（实际是msyscall返回的位置）后的下一句开始执行，因此子进程仅仅只在父进程中被调用了一次。通过判断`sys_env_alloc()`的返回值，明确当前进程的父子身份从而产生不同的返回值。
## Thinking 4.5
---
UTOP及以上的空间在 `env_setup_vm()` 中就已经完成了映射；
USTACKTOP~UTOP之间无需映射；
所以只需要映射USTACKTOP以下的内存空间。
## Thinking 4.6
---
- `vpt` 指向了用户页表，`vpd` 指向用户页目录，通过这两个指针可以实现对用户页表和用户页目录的访问；在使用时，例如 `vpt[vpn]`，我们通过传入虚拟地址 va 对应页表的编号 `vpn` 获得偏移量，接着通过 `((const volatile Pte *)UVPT)` 强制类型转换为页表，加上偏移量后得到对应页表项；
- 实现角度：
	- 在MOS中，存储页表的空间是用户空间，因此用户进程可以通过指针取得页表地址来访问；
	- 虚拟地址是线性映射的，可以实现虚拟地址到虚拟页号的转换；
	- 虚拟地址的对应位分别对应页表和页目录的偏移量，所以方便实现；
- `vpd` 的值为 `(UVPT + (PDX(UVPT) << PGSHIFT))`，意味以 `UVPT` 为基地址，加上偏移 `(PDX(UVPT) << PGSHIFT)` 后，得到UVPT对应的页表项；将其1作为vpd看待，也就可以认为这一页映射了整个页表，可以作为页目录。说明页表中存在某一页映射了整个页表，也就是自映射；
- 不可以，进程只可读页表项，页表系统的管理由操作系统负责；
## Thinking 4.7
---
- 当发生其它异常的时候发生页写入异常的时候，会出现这种"异常重入"；
- 因为异常处理函数都是在用户态下进行的，此时只能访问用户空间；同时，这样也能够方便保存现场，防止被破坏；
## Thinking 4.8
---
- 由用户自己实现页写入异常处理，能够简化操作系统的复杂度，并且避免内核出错的可能；
## Thinking 4.9
---
- 在 `syscall_exofork()` 中会复制父进程的运行空间，此时 `syscall_set_tlb_mod_entry` 所设置的页写入异常处理地址等信息可以一并复制，省了很大的功夫；
- 该函数就是用于处理写时复制保护机制出错的处理的，如果放在其后，可能会导致写时保护机制将不能正确运行；

# 难点分析
---
这次实验主要包括四部分：
1. 了解系统调用并且了解其实现；
2. 实现IPC；
3. 实现fork函数；
4. 实现COW；
5. 页写入异常；
我们一个一个来进行实现：
## 1. 系统调用
---
系统调用的流程分为5步：
1. 在用户态调用 `syscall_*`；
2. `syscall_*` 调用 `msyscall` 陷入内核态；
3. 内核态将异常分发到 `handle_sys` ；
4. 将系统调用信息通过 `do_syscall` 传入内核；
5. 内核执行对应的系统调用函数 `sys_*`;
6. 接着将返回值传递回用户态，回到函数调用处；
![[Pasted image 20240507224213.png]]
这是系统调用的大致流程图。
`user/lib/syscall_lib.c` 中的 `syscall_*` 函数已经实现，主要是用户进行系统调用并且传入参数，一共传入六个参数，前四个都在`$a0-$a3`寄存器中，后两个在栈底部；
`user/lib/syscall_wrap.S` 中的 `msyscall` 是最接近内核的一个函数，通过汇编实现系统调用；
`kern/genex.S` 的异常处理在lab3已经实现；
`kern/syscall_all.c` 中的 `do_syscall` 函数主要是被`handle_sys`调用，这个函数主要是处理用户传入内核态的参数，也就相当于该函数是一个中介函数，连接用户态和内核态的一个管道，通过该函数能够使得用户态正确调用内核态的系统调用函数，并且使得传入参数一致，也就是连接了 `syscall_*` 和 `sys_*`；
`kern/syscall_all.c` 中的 `sys_*` 函数大多是一些基础的系统调用函数，这些函数的实现也相对简单一些；

一些 `sys_*` 函数的实现：
1. `sys_mem_alloc` ：该函数给进程分配页空间；
2. `sys_mem_map` ：该函数将两个进程共享一页物理内存；
3. `sys_mem_unmap` ：该函数解除某个进程对某个进程地址空间虚拟内存和物理内存之间的映射关系；
## 2. IPC
---
IPC是通过进程系统调用实现的进程间通信功能，其目的是使两个进程之间可以通信；
我们实现IPC只需要实现进程共享一个内核空间(主要为kseg0)，并且可以通过这个空间交换数据就够了；
我们只需要实现两个函数，一个为 `sys_ipc_recv()` 用于接受消息，一个为 `sys_ipc_try_send` 用于尝试发送消息；
## 3. Fork
---
fork是进程创建进程，相当于一条河流有了分岔口，分成两个方向进行，有这些特点：
- fork 之前只有父进程存在。
- fork 之后，父子进程同时开始执行 fork 之后的代码段。
- fork 在不同的进程中返回值不一样，在子进程中返回值为 0，在父进程中返回值不为 0， 而为子进程的 pid（Linux 中进程专属的 id，类似于 MOS 中的 envid）。
- 父进程和子进程虽然很多信息相同，但他们的进程控制块是不同的。

fork函数分为下面这些步骤：
1. 通过 `syscall_set_tlb_mod_entry` 函数设置自己的 TLB Mod 异常处理函数，具体实现很简单，就是将异常处理函数的入口设置为 `cow_entry` 即可，也就是设置为写时复制异常处理入口；
	- 在该函数中，我们还实现了 `envid2env` 函数，可以通过传入进程的 `envid` 得到指向该进程 `env` 的指针；
2. 通过 `syscall_exofork` 函数创建一个子进程，该函数需要保存当前进程的运行现场，修改返回值为0，并且设置为不可运行状态等等；
3. 对于子进程，我们直接返回0，对于父进程，我们接着往下走；
4. 我们的父子进程共享了页表，但是页表项并没有设置 `PTE_COW` 位，也就是还没有实现写时复制保护机制，我们需要使用 `duppage` 函数实现该机制；
5. 接着设置子进程的 TLB Mod 异常处理函数为 `cow_entry` 并且将运行状态设置为 `ENV_RUNNABLE`；
## 4. COW
---
该机制就是把地址空间中所有可写页标记为写时复制页面，使得在父进程或子进程对写时复制页面进行写入的时候，能够产生异常；也就是取消 `PTE_D` 而加上 `PTE_COW` 。
该机制主要有函数 `duppage` 实现；
1. 对于只读页面，按照相同权限给子进程；
2. 对于写时复制页面，即具有 PTE_COW 权限位的页面。这类页面是之前的 fork 时 duppage 的结 果，且在本次 fork 前必然未被写入过，所以保持状态就行；
3. 对于共享页面，保持状态即可；
4. 对于可写页面，我们需要在父进程和子进程的页表项中都使用 PTE_COW 权限位进行保护。
## 5. 页写入异常
---
我们可能会碰到页写入异常的处理，处理流程大致为：
1. 用户进程触发页写入异常，陷入到内核中的 handle_mod，再跳转到 do_tlb_mod 函数；
2. do_tlb_mod 函数负责将当前现场保存在异常处理栈中，并设置 a0 和 EPC 寄存器的值，使得从异常恢复后能够以异常处理栈中保存的现场（Trapframe）为参数，跳转到 env_user_tlb_mod_entry 域存储的用户异常处理函数的地址。
3. 从异常恢复到用户态，跳转到用户异常处理函数中，由用户程序完成写时复制等自定义处理。

需要注意的是，与时钟中断等等不同的是，我们页写入异常是在用户态下完成的，所以需要区别于内核态下中断对应的栈空间，我们选择 `UXSTACKTOP` ；
我们通过设置epc的值，让他能够跳转到用户空间，也就是 `tf->cp0_epc = curenv->env_user_tlb_mod_entry;` 也就是让他跳转到 `cow_entry` 函数上；

对于 `cow_entry` 函数，也就是真正处理的部分了，有下面这些步骤：
1. 根据 vpt 中 va 所在页的页表项，判断其标志位是否包含 PTE_COW，是则进行下一步，否则调用 user_panic() 报错。 
2. 分配一个新的临时物理页到临时地址 UCOW，使用 memcpy 将 va 页的数据拷贝到刚刚分配的页中。 
3. 将发生页写入异常的地址 va 映射到临时页面上，注意设定好对应的页面标志位（即去除 PTE_COW 并恢复 PTE_D），然后解除临时地址 UCOW 的内存映射。
# 实验体会
---
这次实验的难度并不高，相比于前几次实验不太难，但是需要做的工作多了，实际上还是那句话，只要理论和实验结合学习，并不算太难；
我们只要理论课上的知识都了解，发现这次实验实际上就是新学习系统调用的知识，都是用系统调用完成的，我们只需要理解系统调用的意义就行了；对于IPC，Fork，COW都是最基本的实现方法，也都是通过系统调用实现的。

这次实验还让我了解了进程创建进程的方法，对于异常处理也不一定都是在内核态下进行的，让我对操作系统了解的更加深入了。

本次实验时间跨度较长，中间还有一个假期，但是不得不说，同一个知识，多次学习的效果是不一样的，我深刻体会到了多次学习这次实验，每一次都给我更加深入的理解！相信上机实验完成后，我还能够有更多不一样的理解！